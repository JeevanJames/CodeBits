#region --- License & Copyright Notice ---
/*
Useful code blocks that can included in your C# projects through NuGet
Copyright (c) 2012-2021 Jeevan James
All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

<auto-generated>
    This code is downloaded from a CodeBits NuGet package.
</auto-generated>
*/
#endregion

#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text.RegularExpressions;

namespace CodeBits
{
    public static class EventArgsExtensions
    {
        /// <summary>
        ///     Fires a status event of type <typeparamref name="TType"/> with the <paramref name="caller"/>
        ///     as the sender.
        /// </summary>
        /// <typeparam name="TType">The type of status being fired.</typeparam>
        /// <param name="caller">The object firing the event.</param>
        /// <param name="handler">The event handler.</param>
        /// <param name="statusType">The status type of the event.</param>
        /// <param name="metadata"></param>
        /// <param name="message"></param>
        public static void FireStatusEvent<TType>(this object caller,
            EventHandler<StatusEventArgs<TType>>? handler,
            TType statusType,
            object? metadata = null,
            string? message = null)
            where TType : Enum
        {
            EventHandler<StatusEventArgs<TType>>? handlerCopy = handler;
            if (handlerCopy is not null)
            {
                var args = new StatusEventArgs<TType>(statusType, message, metadata);
                handlerCopy(caller, args);
            }
        }

        public static void Fire<TType>(this EventHandler<StatusEventArgs<TType>>? handler,
            TType statusType,
            object? metadata = null,
            string? message = null)
            where TType : Enum
        {
            EventHandler<StatusEventArgs<TType>>? handlerCopy = handler;
            if (handlerCopy is not null)
            {
                var args = new StatusEventArgs<TType>(statusType, message, metadata);
                handlerCopy(null, args);
            }
        }
    }

    public sealed class StatusEventArgs<TType> : EventArgs
        where TType : Enum
    {
        public StatusEventArgs(TType statusType, string? message = null, object? metadata = null)
        {
            StatusType = statusType;

            IDictionary<string, object>? metadataBag = null;
            if (metadata is not null)
            {
                metadataBag = metadata.GetType()
                    .GetProperties(BindingFlags.Public | BindingFlags.Instance)
                    .Where(pi => pi.CanRead && pi.GetIndexParameters().Length == 0)
                    .ToDictionary(pi => pi.Name, pi => pi.GetValue(metadata) ?? string.Empty,
                        StringComparer.OrdinalIgnoreCase);
            }

            if (message is null)
                Message = null;
            else if (metadataBag is null)
                Message = message;
            else
            {
                Message = Patterns.PlaceholderPattern.Replace(message, match =>
                    metadataBag.TryGetValue(match.Groups[1].Value, out object? obj) ? obj.ToString() : match.Value);
            }

            Metadata = metadata;
        }

        public TType StatusType { get; }

        public string? Message { get; }

        public object? Metadata { get; }
    }

    internal static class Patterns
    {
        //NOTE: Declared in a separate class as static fields are not shared between different instances
        //of that generic type (Sonar analyzer S2743)
        internal static readonly Regex PlaceholderPattern = new(@"\{(\w+)\}",
            RegexOptions.Compiled | RegexOptions.IgnoreCase, TimeSpan.FromSeconds(1));
    }
}
